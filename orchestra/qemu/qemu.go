package qemu

import (
	"context"
	"fmt"
	"io"
	"log/slog"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/digitalocean/go-qemu/qmp"
	"github.com/jtarchie/ci/orchestra"
)

// QEMU implements orchestra.Driver using a local QEMU virtual machine.
// Commands are executed inside the guest via the QEMU Guest Agent (QGA).
// Volumes are shared between host and guest via 9p virtfs.
type QEMU struct {
	cmd        *exec.Cmd
	monitor    *qmp.SocketMonitor
	qga        *QGAClient
	namespace  string
	logger     *slog.Logger
	tempDir    string
	volumesDir string
	params     map[string]string

	bootOnce sync.Once
	bootErr  error

	mu         sync.Mutex
	containers map[string]*Container

	// config parsed from DSN
	memory    string
	cpus      string
	accel     string
	qemuBin   string
	cacheDir  string
	imagePath string
}

// Name returns the driver name.
func (q *QEMU) Name() string {
	return "qemu"
}

// NewQEMU creates a new QEMU driver.
func NewQEMU(namespace string, logger *slog.Logger, params map[string]string) (orchestra.Driver, error) {
	homeDir, _ := os.UserHomeDir()
	defaultCacheDir := filepath.Join(homeDir, ".cache", "ci", "qemu")

	defaultAccel := "tcg"
	switch runtime.GOOS {
	case "darwin":
		defaultAccel = "hvf"
	case "linux":
		if _, err := os.Stat("/dev/kvm"); err == nil {
			defaultAccel = "kvm"
		}
	}

	defaultBinary := "qemu-system-x86_64"
	if runtime.GOARCH == "arm64" {
		defaultBinary = "qemu-system-aarch64"
	}

	q := &QEMU{
		namespace:  namespace,
		logger:     logger,
		params:     params,
		containers: make(map[string]*Container),
		memory:     orchestra.GetParam(params, "memory", "QEMU_MEMORY", "2048"),
		cpus:       orchestra.GetParam(params, "cpus", "QEMU_CPUS", "2"),
		accel:      orchestra.GetParam(params, "accel", "QEMU_ACCEL", defaultAccel),
		qemuBin:    orchestra.GetParam(params, "qemu_binary", "QEMU_BINARY", defaultBinary),
		cacheDir:   orchestra.GetParam(params, "cache_dir", "QEMU_CACHE_DIR", defaultCacheDir),
		imagePath:  orchestra.GetParam(params, "image", "QEMU_IMAGE", ""),
	}

	return q, nil
}

// ensureVM lazily boots the QEMU VM on first use. Idempotent.
func (q *QEMU) ensureVM(ctx context.Context) error {
	q.bootOnce.Do(func() {
		q.bootErr = q.bootVM(ctx)
	})

	return q.bootErr
}

// bootVM performs the actual VM boot. Called once by ensureVM.
func (q *QEMU) bootVM(ctx context.Context) error {

	q.logger.Info("qemu.vm.starting", "namespace", q.namespace)

	// Create temp dir for runtime files
	tempDir, err := os.MkdirTemp("", fmt.Sprintf("ci-qemu-%s-", q.namespace))
	if err != nil {
		return fmt.Errorf("failed to create temp dir: %w", err)
	}

	q.tempDir = tempDir

	// Create volumes directory inside temp dir
	q.volumesDir = filepath.Join(tempDir, "volumes")
	if err := os.MkdirAll(q.volumesDir, 0o755); err != nil {
		return fmt.Errorf("failed to create volumes dir: %w", err)
	}

	// Prepare the disk image
	baseImage := q.imagePath
	if baseImage == "" {
		q.logger.Info("qemu.image.downloading", "cache_dir", q.cacheDir)

		baseImage, err = downloadImage(q.cacheDir)
		if err != nil {
			return fmt.Errorf("failed to download image: %w", err)
		}

		q.logger.Info("qemu.image.ready", "path", baseImage)
	}

	// Create overlay (COW) so we never modify the base image
	overlayPath := filepath.Join(tempDir, "disk.qcow2")
	if err := createOverlay(baseImage, overlayPath); err != nil {
		return fmt.Errorf("failed to create overlay: %w", err)
	}

	// Create cloud-init seed ISO
	seedPath := filepath.Join(tempDir, "seed.iso")
	if err := createSeedISO(seedPath, q.namespace); err != nil {
		return fmt.Errorf("failed to create seed ISO: %w", err)
	}

	// Socket paths
	qmpSock := filepath.Join(tempDir, "qmp.sock")

	// Find a free TCP port for QGA
	qgaPort, err := findFreePort()
	if err != nil {
		return fmt.Errorf("failed to find free port for QGA: %w", err)
	}

	qgaAddr := fmt.Sprintf("127.0.0.1:%d", qgaPort)

	// Build QEMU command
	args := q.buildQEMUArgs(overlayPath, seedPath, qmpSock, qgaPort)

	q.logger.Info("qemu.vm.command", "binary", q.qemuBin, "args", strings.Join(args, " "))

	cmd := exec.Command(q.qemuBin, args...) //nolint:gosec
	cmd.Stdout = os.Stderr
	cmd.Stderr = os.Stderr
	q.cmd = cmd

	if err := cmd.Start(); err != nil {
		return fmt.Errorf("failed to start QEMU: %w", err)
	}

	q.logger.Info("qemu.vm.started", "pid", cmd.Process.Pid)

	// Connect QMP monitor
	if err := q.connectQMP(ctx, qmpSock); err != nil {
		return fmt.Errorf("failed to connect QMP: %w", err)
	}

	q.logger.Info("qemu.qmp.connected")

	// Wait for QGA to become available
	if err := q.connectQGA(ctx, qgaAddr); err != nil {
		return fmt.Errorf("failed to connect QGA: %w", err)
	}

	q.logger.Info("qemu.qga.connected")

	// Mount 9p volumes inside guest
	if err := q.mountVolumes(); err != nil {
		q.logger.Warn("qemu.volumes.mount.failed", "err", err)
		// Non-fatal â€” volumes may mount later on demand
	}

	return nil
}

// buildQEMUArgs constructs the QEMU command-line arguments.
func (q *QEMU) buildQEMUArgs(overlayPath, seedPath, qmpSock string, qgaPort int) []string {
	args := []string{
		"-nographic",
		"-serial", "none",
		"-m", q.memory,
		"-smp", q.cpus,
		"-accel", q.accel,
	}

	// Machine type
	if runtime.GOARCH == "arm64" {
		args = append(args, "-machine", "virt")
		args = append(args, "-cpu", "host")

		// UEFI firmware for aarch64
		efiPaths := []string{
			"/opt/homebrew/share/qemu/edk2-aarch64-code.fd", // Homebrew Apple Silicon
			"/usr/local/share/qemu/edk2-aarch64-code.fd",    // Homebrew Intel
			"/usr/share/AAVMF/AAVMF_CODE.fd",                // Debian/Ubuntu
			"/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw",   // Fedora
			"/usr/share/qemu-efi-aarch64/QEMU_EFI.fd",       // Alpine
		}

		for _, path := range efiPaths {
			if _, err := os.Stat(path); err == nil {
				args = append(args, "-bios", path)

				break
			}
		}
	} else {
		args = append(args, "-machine", "q35")
		if q.accel == "tcg" {
			args = append(args, "-cpu", "max")
		} else {
			args = append(args, "-cpu", "host")
		}
	}

	// Boot disk
	args = append(args,
		"-drive", fmt.Sprintf("file=%s,if=virtio,format=qcow2", overlayPath),
	)

	// Cloud-init seed ISO
	args = append(args,
		"-drive", fmt.Sprintf("file=%s,if=virtio,format=raw", seedPath),
	)

	// QMP monitor socket
	args = append(args,
		"-qmp", fmt.Sprintf("unix:%s,server=on,wait=off", qmpSock),
	)

	// QGA virtio-serial channel (TCP socket for reliable reconnection)
	args = append(args,
		"-chardev", fmt.Sprintf("socket,host=127.0.0.1,port=%d,server=on,wait=off,id=qga0", qgaPort),
		"-device", "virtio-serial",
		"-device", "virtserialport,chardev=qga0,name=org.qemu.guest_agent.0",
	)

	// 9p shared volumes directory
	args = append(args,
		"-virtfs", fmt.Sprintf("local,path=%s,mount_tag=volumes,security_model=mapped-xattr,id=volumes", q.volumesDir),
	)

	return args
}

// connectQMP connects to the QMP monitor socket with retries.
func (q *QEMU) connectQMP(ctx context.Context, sockPath string) error {
	deadline := time.After(60 * time.Second)

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-deadline:
			return fmt.Errorf("timeout waiting for QMP socket at %s", sockPath)
		default:
		}

		if _, err := os.Stat(sockPath); err != nil {
			time.Sleep(500 * time.Millisecond)

			continue
		}

		mon, err := qmp.NewSocketMonitor("unix", sockPath, 5*time.Second)
		if err != nil {
			time.Sleep(500 * time.Millisecond)

			continue
		}

		if err := mon.Connect(); err != nil {
			time.Sleep(500 * time.Millisecond)

			continue
		}

		q.monitor = mon

		return nil
	}
}

// connectQGA connects to the QGA TCP socket with retries.
// Waits for the guest to boot, cloud-init to finish, and the guest agent to stabilize.
func (q *QEMU) connectQGA(ctx context.Context, addr string) error {
	deadline := time.After(300 * time.Second)

	// Phase 1: Wait for cloud-init to finish by polling boot-finished file.
	q.logger.Debug("qemu.qga.waiting-for-cloud-init")

	cloudInitDone := false

	for !cloudInitDone {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-deadline:
			return fmt.Errorf("timeout waiting for cloud-init to finish")
		default:
		}

		client, err := NewQGAClient("tcp", addr)
		if err != nil {
			q.logger.Debug("qemu.qga.cloud-init.connect-retry", "err", err)
			time.Sleep(3 * time.Second)

			continue
		}

		pid, err := client.Exec("/bin/sh", []string{"-c",
			"test -f /var/lib/cloud/instance/boot-finished",
		}, nil, nil)
		if err != nil {
			_ = client.Close()
			q.logger.Debug("qemu.qga.cloud-init.exec-retry", "err", err)
			time.Sleep(3 * time.Second)

			continue
		}

		time.Sleep(time.Second)

		result, err := client.ExecStatus(pid)

		_ = client.Close()

		if err != nil {
			q.logger.Debug("qemu.qga.cloud-init.status-retry", "err", err)
			time.Sleep(3 * time.Second)

			continue
		}

		if result.Exited && result.ExitCode == 0 {
			cloudInitDone = true

			q.logger.Info("qemu.cloud-init.finished")
		} else {
			q.logger.Debug("qemu.qga.cloud-init.not-ready", "exited", result.Exited, "exit_code", result.ExitCode)
			time.Sleep(3 * time.Second)
		}
	}

	// Phase 2: Establish stable connection with full exec cycle verification
	q.logger.Debug("qemu.qga.connecting-final")

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-deadline:
			return fmt.Errorf("timeout waiting for stable QGA connection")
		default:
		}

		client, err := NewQGAClient("tcp", addr)
		if err != nil {
			q.logger.Debug("qemu.qga.final-connect.retry", "err", err)
			time.Sleep(3 * time.Second)

			continue
		}

		// Verify with a full exec + exec-status cycle
		pid, err := client.Exec("/bin/echo", []string{"ready"}, nil, nil)
		if err != nil {
			_ = client.Close()
			q.logger.Debug("qemu.qga.final-exec.retry", "err", err)
			time.Sleep(3 * time.Second)

			continue
		}

		time.Sleep(time.Second)

		result, err := client.ExecStatus(pid)
		if err != nil {
			_ = client.Close()
			q.logger.Debug("qemu.qga.final-status.retry", "err", err)
			time.Sleep(3 * time.Second)

			continue
		}

		if !result.Exited || result.ExitCode != 0 {
			_ = client.Close()
			q.logger.Debug("qemu.qga.final-check.failed", "exited", result.Exited, "exit_code", result.ExitCode)
			time.Sleep(3 * time.Second)

			continue
		}

		q.qga = client

		return nil
	}
}

// mountVolumes mounts the 9p shared directory inside the guest.
func (q *QEMU) mountVolumes() error {
	// Create mount point and mount the 9p filesystem
	pid, err := q.qga.Exec("/bin/sh", []string{"-c",
		"mkdir -p /mnt/volumes && " +
			"(mountpoint -q /mnt/volumes || mount -t 9p -o trans=virtio,version=9p2000.L,msize=104857600 volumes /mnt/volumes)",
	}, nil, nil)
	if err != nil {
		return fmt.Errorf("failed to start mount command: %w", err)
	}

	// Wait for the mount command to complete
	for range 30 {
		result, err := q.qga.ExecStatus(pid)
		if err != nil {
			return fmt.Errorf("failed to check mount status: %w", err)
		}

		if result.Exited {
			if result.ExitCode != 0 {
				return fmt.Errorf("mount command exited with code %d", result.ExitCode)
			}

			return nil
		}

		time.Sleep(time.Second)
	}

	return fmt.Errorf("timeout waiting for mount command")
}

// RunContainer executes a command inside the QEMU guest via QGA.
func (q *QEMU) RunContainer(ctx context.Context, task orchestra.Task) (orchestra.Container, error) {
	if err := q.ensureVM(ctx); err != nil {
		return nil, fmt.Errorf("failed to ensure VM: %w", err)
	}

	q.mu.Lock()

	// Idempotency: return existing container if same task ID
	if existing, ok := q.containers[task.ID]; ok {
		q.mu.Unlock()

		return existing, nil
	}

	q.mu.Unlock()

	// Handle mounts: create directories on host and bind-mount inside guest
	for _, mount := range task.Mounts {
		hostPath := filepath.Join(q.volumesDir, mount.Name)

		if err := os.MkdirAll(hostPath, 0o755); err != nil {
			return nil, fmt.Errorf("failed to create volume dir: %w", err)
		}

		// Create the mount path inside guest and bind-mount from 9p share
		mountCmd := fmt.Sprintf(
			"mkdir -p %s && (mountpoint -q %s || mount --bind /mnt/volumes/%s %s)",
			mount.Path, mount.Path, mount.Name, mount.Path,
		)

		pid, err := q.qga.Exec("/bin/sh", []string{"-c", mountCmd}, nil, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to mount volume: %w", err)
		}

		// Wait for mount to complete
		for range 15 {
			result, err := q.qga.ExecStatus(pid)
			if err != nil {
				return nil, fmt.Errorf("failed to check mount status: %w", err)
			}

			if result.Exited {
				if result.ExitCode != 0 {
					q.logger.Warn("qemu.mount.failed", "name", mount.Name, "exit_code", result.ExitCode)
				}

				break
			}

			time.Sleep(500 * time.Millisecond)
		}
	}

	// Build environment variables
	var env []string
	for k, v := range task.Env {
		env = append(env, fmt.Sprintf("%s=%s", k, v))
	}

	if task.Image != "" {
		q.logger.Debug("qemu.image.ignored", "image", task.Image, "msg", "QEMU driver runs commands directly in the guest OS")
	}

	// Read stdin if provided
	var stdinData []byte
	if task.Stdin != nil {
		var err error

		stdinData, err = io.ReadAll(task.Stdin)
		if err != nil {
			return nil, fmt.Errorf("failed to read stdin: %w", err)
		}
	}

	// Execute the command via QGA
	pid, err := q.qga.Exec(task.Command[0], task.Command[1:], env, stdinData)
	if err != nil {
		return nil, fmt.Errorf("failed to exec command: %w", err)
	}

	container := &Container{
		qga:    q.qga,
		pid:    pid,
		taskID: task.ID,
	}

	q.mu.Lock()
	q.containers[task.ID] = container
	q.mu.Unlock()

	return container, nil
}

// CreateVolume creates a shared directory accessible to the guest.
func (q *QEMU) CreateVolume(ctx context.Context, name string, _ int) (orchestra.Volume, error) {
	if err := q.ensureVM(ctx); err != nil {
		return nil, fmt.Errorf("failed to ensure VM: %w", err)
	}

	hostPath := filepath.Join(q.volumesDir, name)

	if err := os.MkdirAll(hostPath, 0o755); err != nil {
		return nil, fmt.Errorf("failed to create volume dir: %w", err)
	}

	return &Volume{
		name:     name,
		hostPath: hostPath,
	}, nil
}

// GetContainer returns an existing container by task ID.
func (q *QEMU) GetContainer(_ context.Context, containerID string) (orchestra.Container, error) {
	q.mu.Lock()
	defer q.mu.Unlock()

	if container, ok := q.containers[containerID]; ok {
		return container, nil
	}

	return nil, orchestra.ErrContainerNotFound
}

// Close shuts down the QEMU VM and cleans up all resources.
func (q *QEMU) Close() error {
	var errs []error

	// Send quit command via QMP
	if q.monitor != nil {
		_, _ = q.monitor.Run([]byte(`{"execute":"quit"}`))
		_ = q.monitor.Disconnect()
	}

	// Close QGA connection
	if q.qga != nil {
		_ = q.qga.Close()
	}

	// Wait for QEMU process to exit
	if q.cmd != nil && q.cmd.Process != nil {
		done := make(chan error, 1)
		go func() {
			done <- q.cmd.Wait()
		}()

		select {
		case <-done:
			// Process exited
		case <-time.After(10 * time.Second):
			// Force kill if it doesn't stop
			_ = q.cmd.Process.Kill()
			<-done
		}
	}

	// Clean up temp directory
	if q.tempDir != "" {
		if err := os.RemoveAll(q.tempDir); err != nil {
			errs = append(errs, fmt.Errorf("failed to remove temp dir: %w", err))
		}
	}

	if len(errs) > 0 {
		return fmt.Errorf("close errors: %v", errs)
	}

	return nil
}

// qemuImgCommand creates an exec.Cmd for qemu-img.
func qemuImgCommand(args ...string) *exec.Cmd {
	return exec.Command("qemu-img", args...) //nolint:gosec
}

// findFreePort asks the OS for a free TCP port.
func findFreePort() (int, error) {
	listener, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		return 0, err
	}

	port := listener.Addr().(*net.TCPAddr).Port

	_ = listener.Close()

	return port, nil
}

func init() {
	orchestra.Add("qemu", NewQEMU)
}

var (
	_ orchestra.Driver          = (*QEMU)(nil)
	_ orchestra.Container       = (*Container)(nil)
	_ orchestra.ContainerStatus = (*Status)(nil)
	_ orchestra.Volume          = (*Volume)(nil)
)
