package storage_test

import (
	"context"
	"log/slog"
	"os"
	"testing"

	"github.com/jtarchie/ci/storage"
	_ "github.com/jtarchie/ci/storage/sqlite"
	. "github.com/onsi/gomega"
)

func TestFTS(t *testing.T) {
	t.Parallel()
	storage.Each(func(name string, init storage.InitFunc) {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			t.Run("SearchPipelines", func(t *testing.T) {
				t.Parallel()
				t.Run("returns all pipelines when query is empty", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					_, err = client.SavePipeline(context.Background(), "hello-world", "echo hello", "native://", "")
					assert.Expect(err).NotTo(HaveOccurred())
					result, err := client.SearchPipelines(context.Background(), "", 1, 20)
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(result.Items).To(HaveLen(1))
					assert.Expect(result.Items[0].Name).To(Equal("hello-world"))
				})
				t.Run("finds pipeline by name token", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					_, err = client.SavePipeline(context.Background(), "hello-world", "echo hello", "native://", "")
					assert.Expect(err).NotTo(HaveOccurred())
					_, err = client.SavePipeline(context.Background(), "deploy-prod", "kubectl apply", "native://", "")
					assert.Expect(err).NotTo(HaveOccurred())
					result, err := client.SearchPipelines(context.Background(), "hello", 1, 20)
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(result.Items).To(HaveLen(1))
					assert.Expect(result.Items[0].Name).To(Equal("hello-world"))
				})
				t.Run("finds pipeline by content keyword", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					_, err = client.SavePipeline(context.Background(), "pipeline-a", "run unit tests with pytest", "native://", "")
					assert.Expect(err).NotTo(HaveOccurred())
					_, err = client.SavePipeline(context.Background(), "pipeline-b", "deploy to kubernetes", "native://", "")
					assert.Expect(err).NotTo(HaveOccurred())
					result, err := client.SearchPipelines(context.Background(), "pytest", 1, 20)
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(result.Items).To(HaveLen(1))
					assert.Expect(result.Items[0].Name).To(Equal("pipeline-a"))
				})
				t.Run("returns empty when no pipeline matches", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					_, err = client.SavePipeline(context.Background(), "hello", "echo hi", "native://", "")
					assert.Expect(err).NotTo(HaveOccurred())
					result, err := client.SearchPipelines(context.Background(), "zzznomatch", 1, 20)
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(result.Items).To(BeEmpty())
				})
				t.Run("prefix matching works for partial tokens", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					_, err = client.SavePipeline(context.Background(), "integration-tests", "run integration suite", "native://", "")
					assert.Expect(err).NotTo(HaveOccurred())
					result, err := client.SearchPipelines(context.Background(), "integr", 1, 20)
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(result.Items).To(HaveLen(1))
				})
			})
			t.Run("Set + Search", func(t *testing.T) {
				t.Parallel()
				t.Run("finds task by stdout content", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					runID := "run-abc"
					taskKey := "/pipeline/" + runID + "/tasks/step-1"
					err = client.Set(context.Background(), taskKey, map[string]any{"stdout": "build passed successfully", "stderr": ""})
					assert.Expect(err).NotTo(HaveOccurred())
					results, err := client.Search(context.Background(), "pipeline/"+runID, "passed")
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(results).To(HaveLen(1))
				})
				t.Run("finds task by stderr content", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					runID := "run-xyz"
					taskKey := "/pipeline/" + runID + "/tasks/step-1"
					err = client.Set(context.Background(), taskKey, map[string]any{"stdout": "", "stderr": "error: connection refused"})
					assert.Expect(err).NotTo(HaveOccurred())
					results, err := client.Search(context.Background(), "pipeline/"+runID, "connection")
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(results).To(HaveLen(1))
				})
				t.Run("search is scoped to the requested run", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					run1 := "run-111"
					run2 := "run-222"
					err = client.Set(context.Background(), "/pipeline/"+run1+"/tasks/step-1", map[string]any{"stdout": "unique-token-alpha"})
					assert.Expect(err).NotTo(HaveOccurred())
					err = client.Set(context.Background(), "/pipeline/"+run2+"/tasks/step-1", map[string]any{"stdout": "unique-token-alpha"})
					assert.Expect(err).NotTo(HaveOccurred())
					results, err := client.Search(context.Background(), "pipeline/"+run1, "alpha")
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(results).To(HaveLen(1))
					for _, r := range results {
						assert.Expect(r.Path).To(ContainSubstring(run1))
					}
				})
				t.Run("ANSI codes are stripped so plain-text search succeeds", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					runID := "run-ansi"
					taskKey := "/pipeline/" + runID + "/tasks/step-1"
					ansiOutput := "\x1b[32mBUILD_SUCCESS\x1b[0m: all tests passed"
					err = client.Set(context.Background(), taskKey, map[string]any{"stdout": ansiOutput, "stderr": ""})
					assert.Expect(err).NotTo(HaveOccurred())
					results, err := client.Search(context.Background(), "pipeline/"+runID, "BUILD_SUCCESS")
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(results).To(HaveLen(1))
					results, err = client.Search(context.Background(), "pipeline/"+runID, "\\x1b")
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(results).To(BeEmpty())
				})
				t.Run("empty query returns nil results", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					results, err := client.Search(context.Background(), "pipeline/run-123", "")
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(results).To(BeEmpty())
				})
				t.Run("re-indexing a task via Set replaces old FTS entry", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					runID := "run-reindex"
					taskKey := "/pipeline/" + runID + "/tasks/step-1"
					err = client.Set(context.Background(), taskKey, map[string]any{"stdout": "first-run-output"})
					assert.Expect(err).NotTo(HaveOccurred())
					err = client.Set(context.Background(), taskKey, map[string]any{"stdout": "second-run-output"})
					assert.Expect(err).NotTo(HaveOccurred())
					results, err := client.Search(context.Background(), "pipeline/"+runID, "first")
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(results).To(BeEmpty())
					results, err = client.Search(context.Background(), "pipeline/"+runID, "second")
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(results).To(HaveLen(1))
				})
				t.Run("path components are searchable", func(t *testing.T) {
					t.Parallel()
					assert := NewGomegaWithT(t)
					buildFile, err := os.CreateTemp(t.TempDir(), "")
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = buildFile.Close() }()
					client, err := init(buildFile.Name(), "ns", slog.Default())
					assert.Expect(err).NotTo(HaveOccurred())
					defer func() { _ = client.Close() }()
					runID := "run-pathsearch"
					// step-1 and step-2 have the same payload; only their path differs
					err = client.Set(context.Background(), "/pipeline/"+runID+"/tasks/compile-sources", map[string]any{"status": "success"})
					assert.Expect(err).NotTo(HaveOccurred())
					err = client.Set(context.Background(), "/pipeline/"+runID+"/tasks/run-tests", map[string]any{"status": "success"})
					assert.Expect(err).NotTo(HaveOccurred())
					// Searching for the task name embedded in the path should find only that task
					results, err := client.Search(context.Background(), "pipeline/"+runID, "compile")
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(results).To(HaveLen(1))
					assert.Expect(results[0].Path).To(ContainSubstring("compile-sources"))
					// Searching for the other task name should find only that one
					results, err = client.Search(context.Background(), "pipeline/"+runID, "run-tests")
					assert.Expect(err).NotTo(HaveOccurred())
					assert.Expect(results).To(HaveLen(1))
					assert.Expect(results[0].Path).To(ContainSubstring("run-tests"))
				})
			})
		})
	})
}
